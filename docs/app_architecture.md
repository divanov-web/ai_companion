# Архитектура текущего приложения 

Нужно разделять код на логические слои. По-воможности создавать интерфейсы и работать через них в слое верхнего уровня.
Использовать DI для каждой вложенности.
Сообщение — на языке приложения это одно сообщение в чат или пакет Responses в библиотеке openai-go.
Диалог — набор сообщений между пользователем с общим контекстом. Контекст объединяется на стороне OpenAI API через conversation.

## Слои
1. Клиентский код: Пока что это main.go до рефакторинга
2. Слой сервиса services: Обработка задач клиентского кода. Формирования запроса, создание и управление диалогами, отправка сообщений.
3. Слой клиента (нужно придумать название, типа client или request или method, разные виды запросов): (заменяет repository в каком-то смысле) Сами запросы к OpenAI API с нужными параметрами. 
Нужны два интерфейса: создание диалогов Conversations (1 реализация), создание сообщений (1 реализации, текст с картинкой)

## Реализации
1. Клиент диалогов, реализация:
conv, err := c.client.Conversations.New(ctx, conversations.ConversationNewParams{})
if err != nil {
return "", err
}
Должен формировать описание диалога
2. Клиент сообщений с картинками: c.client.Responses.New
должен подставлять conversation.ID в запрос из принимаемого параметра, опционально.

### Правила диалогов OpenAI api
1. Используем в OpenAI api технологию Responses API, Chat Completions API считать устаревшей
2. Создать conversation (диалог) через client.Conversations.New и задать первоначальные параметры ответов ИИ и дать водные "Кто ты такой"
3. Все запросы добавлять через созданный диалог Conversation: responses.ResponseNewParamsConversationUnion{OfString: openai.String(conv.ID)},

## Следующие шаги
- Ввести пакет домена и адаптер OpenAI.
- Добавить конфигурацию через env и логирование.
